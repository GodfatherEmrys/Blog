{"pageProps":{"journalPosts":{"key":"journal","posts":[],"children":[{"key":"developments","posts":[{"key":"journal/developments/2020-10-04-분할정복.md","title":"분할정복","filename":"2020-10-04-분할정복.md","slug":"journal/developments/2020-10-04-분할정복","writtenAt":"2020-10-04","categories":["journal","developments"],"postURI":"journal/developments/2020-10-04-분할정복.md","content":"<h1 id=\"분할정복\">분할정복</h1>\n<blockquote>\n<p>Devide &amp; Conquer</p>\n</blockquote>\n<p>분할 정복은 하나의 문제를 두개 이상의 문제로 나누어 각각의 조각의 문제들의 답을 구하는 방식으로 최종적으로 전체 문제의 답을 다시 구하는 방식이다. 따라서 분할 정복을 사용할 수 있는 문제는 나누어질 수 있어야 하고, 그 나눠진 조각들은 같은 크기의 문제들이어야 한다.</p>\n<p>분할 정복을 사용하는 알고리즘들은 대체로 세 가지의 구성요소를 가지고 있다.</p>\n<ol>\n<li>문제를 더 작은 문제로 분할한다.</li>\n<li>더이상 답을 분할할 수 없는 작은 문제와 나머지 같은 크기의 문제로 나누어진다.</li>\n<li>각 문제에 구한 답을 재귀적으로 원래 문제에 대한 답으로 합친다.</li>\n</ol>\n<h2 id=\"수열의-합\">수열의 합</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">number</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (number === <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (number % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">return</span> sum(number - <span class=\"hljs-number\">1</span>) + number;\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * sum(number / <span class=\"hljs-number\">2</span>) + (number / <span class=\"hljs-number\">2</span>) * (number / <span class=\"hljs-number\">2</span>);\n}</code></pre>\n<h2 id=\"과반수-엘리먼트\">과반수 엘리먼트</h2>\n<p>과반수를 차지하는 엘리먼트를 출력하라.</p>\n<h3 id=\"brute-force\">Brute force</h3>\n<blockquote>\n<p>Brute force 로는 시간제한을 넘게 된다.</p>\n</blockquote>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">majorityElement</span>(<span class=\"hljs-params\">numbers = []</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> numbersLength = numbers.length;\n  <span class=\"hljs-keyword\">const</span> majorityStandardLength = numbersLength / <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; numbersLength; i++) {\n    <span class=\"hljs-keyword\">const</span> currentNumber = numbers[i];\n    <span class=\"hljs-keyword\">const</span> currentNumberCount = numbers.filter(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">number</span>) =&gt;</span> number === currentNumber\n    ).length;\n    <span class=\"hljs-keyword\">if</span> (currentNumberCount &gt; majorityStandardLength) {\n      <span class=\"hljs-keyword\">return</span> currentNumber;\n    }\n  }\n}</code></pre>\n<h3 id=\"dynamic-programming\">Dynamic Programming</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> counts = [];\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">majorityElement</span>(<span class=\"hljs-params\">numbers = []</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> numbersLength = numbers.length;\n  <span class=\"hljs-keyword\">const</span> majorityStandardLength = numbersLength / <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; numbersLength; i++) {\n    <span class=\"hljs-keyword\">const</span> currentNumber = numbers[i];\n\n    <span class=\"hljs-keyword\">if</span> (!counts[currentNumber]) {\n      counts[currentNumber] = numbers.filter(\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">number</span>) =&gt;</span> number === currentNumber\n      ).length;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (counts[currentNumber] &gt; majorityStandardLength) {\n      <span class=\"hljs-keyword\">return</span> currentNumber;\n    }\n  }\n}</code></pre>\n<h3 id=\"devide--conquer\">Devide &amp; Conquer</h3>\n","data":{"titlePrefix":"Algorithm","title":"분할정복"},"isEmpty":false,"excerpt":"","titlePrefix":"Algorithm"},{"key":"journal/developments/2020-10-05-자료구조 - 배열.md","title":"Array","filename":"2020-10-05-자료구조 - 배열.md","slug":"journal/developments/2020-10-05-자료구조 - 배열","writtenAt":"2020-10-05","categories":["journal","developments"],"postURI":"journal/developments/2020-10-05-자료구조 - 배열.md","content":"<h1 id=\"자료구조---배열\">자료구조 - 배열</h1>\n<blockquote>\n<p><a href=\"https://colab.research.google.com/drive/1a49URb-3oN0qXleYL5_hbiZYDSE7BPgs?hl=ko#scrollTo=bMd74RrRwKBY\">https://colab.research.google.com/drive/1a49URb-3oN0qXleYL5_hbiZYDSE7BPgs?hl=ko#scrollTo=bMd74RrRwKBY</a></p>\n</blockquote>\n<ul>\n<li>데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조</li>\n<li>파이썬에서는 리스트 타입이 배열 기능을 제공하고 있음</li>\n</ul>\n<h2 id=\"1-배열이-왜-필요할까\">1. 배열이 왜 필요할까?</h2>\n<ul>\n<li>같은 종류의 데이터를 효율적으로 관리하기 위해 사용</li>\n<li>같은 종류의 데이터를 순차적으로 저장</li>\n</ul>\n<h3 id=\"배열의-장점\">배열의 장점</h3>\n<ul>\n<li>빠른 접근</li>\n</ul>\n<h3 id=\"배열의-단점\">배열의 단점</h3>\n<ul>\n<li>미리 정해진 범위 이상의 데이터의 추가가 어렵다</li>\n<li>데이터가 가변적이라면 비효율적 (추가/삭제가 쉽지 않음)</li>\n</ul>\n","data":{"titlePrefix":"DataStructure","title":"Array"},"isEmpty":false,"excerpt":"","titlePrefix":"DataStructure"},{"key":"journal/developments/2020-10-06-소수구하기.md","title":"소수구하기","filename":"2020-10-06-소수구하기.md","slug":"journal/developments/2020-10-06-소수구하기","writtenAt":"2020-10-06","categories":["journal","developments"],"postURI":"journal/developments/2020-10-06-소수구하기.md","content":"<h1 id=\"소수-구하기\">소수 구하기</h1>\n<h2 id=\"소수\">소수</h2>\n<p>1과 자기 자신으로만 나눠지는 2 이상의 정수</p>\n<h2 id=\"소수를-구하는-기본-방법\">소수를 구하는 기본 방법</h2>\n<p>소수가 아닌 수를 걸러낸다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getMinority</span>(<span class=\"hljs-params\">number</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> numbers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(number);\n\n  numbers[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n  numbers[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">2</span>; i &lt; number; i++) {\n    <span class=\"hljs-keyword\">if</span> (!numbers[i]) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">2</span> * i; j &lt;= number; j += i) {\n        numbers[j] = <span class=\"hljs-number\">1</span>;\n      }\n    }\n  }\n  <span class=\"hljs-built_in\">console</span>.log(numbers);\n  <span class=\"hljs-keyword\">const</span> minorities = [];\n  <span class=\"hljs-keyword\">const</span> numbersLength = numbers.length;\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">2</span>; i &lt; number; i++) {\n    <span class=\"hljs-keyword\">if</span> (!numbers[i]) {\n      minorities.push(i);\n    }\n  }\n\n  <span class=\"hljs-built_in\">console</span>.log(minorities);\n}</code></pre>\n<p>단순하게 할 경우 숫자의 중복이 많이 발생하여 계산을 끝없이 해야하는 경우가 생길 수 있지만, 이렇게 배수들을 미리 제거하면서 할 경우 이중 반복문이라고 하더라도 훨씬 빠르게 계산할 수 있다. 소수에서 이렇게 배수들을 미리 제거하면서 하는 방법을 <code>에라토스체네스의 체</code>로 걸러낸다고 한다.</p>\n","data":{},"isEmpty":false,"excerpt":""},{"key":"journal/developments/2020-10-11-나눗셈.md","title":"나눗셈","filename":"2020-10-11-나눗셈.md","slug":"journal/developments/2020-10-11-나눗셈","writtenAt":"2020-10-11","categories":["journal","developments"],"postURI":"journal/developments/2020-10-11-나눗셈.md","content":"<h1 id=\"나눗셈\">나눗셈</h1>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">divide</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> q = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">var</span> r = a;\n  <span class=\"hljs-keyword\">if</span> (b == <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  }\n\n  <span class=\"hljs-keyword\">while</span> (r &gt;= b) {\n    r = r - b;\n    q = q + <span class=\"hljs-number\">1</span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> [q, r];\n}</code></pre>\n","data":{},"isEmpty":false,"excerpt":""},{"key":"journal/developments/2020-10-12-이진탐색.md","title":"Binary Search","filename":"2020-10-12-이진탐색.md","slug":"journal/developments/2020-10-12-이진탐색","writtenAt":"2020-10-12","categories":["journal","developments"],"postURI":"journal/developments/2020-10-12-이진탐색.md","content":"<h1 id=\"이진-탐색\">이진 탐색</h1>\n<p>이진 탐색(Binary search)은 검색의 범위를 반씩 나누어가면서 찾는 탐색이라고 한다. 술자리에서 종종하는 <code>up&amp;down</code> 이라는 게임이 있다. 병뚜껑에 있는 숫자를 맞추는 건데, 보통 이것을 할 때 이진검색으로 하게 된다. 술 병뚜껑에는 <code>1</code> ~ <code>50</code>까지의 숫자가 있기 때문에 <code>25</code>부터 시작해서 이진 탐색을 하면 된다. 그럼 짧은 횟수만에 찾아내어 술을 한 잔 마실 수 있다.</p>\n","data":{"titlePrefix":"Algorithm","title":"Binary Search"},"isEmpty":false,"excerpt":"","titlePrefix":"Algorithm"},{"key":"journal/developments/2020-10-19-테스트 코드.md","title":"테스트 개요","filename":"2020-10-19-테스트 코드.md","slug":"journal/developments/2020-10-19-테스트 코드","writtenAt":"2020-10-19","categories":["journal","developments"],"postURI":"journal/developments/2020-10-19-테스트 코드.md","content":"<h1 id=\"테스트\">테스트</h1>\n<blockquote>\n<p>이 문서는 <a href=\"https://www.manning.com/books/react-in-action\">React in Action</a>의 내용을 학습한 것을 토대로 정리/추가한 것입니다.</p>\n</blockquote>\n<h2 id=\"테스트의-종류\">테스트의 종류</h2>\n<ul>\n<li>단위 테스트 (Unit Test): 단위 테스트는 기능의 개별적인 단위를 테스트합니다. 하나의 메서드가 제대로 기능하고 있는지에 대해 집중하는 테스트입니다. 이 테스트를 통해 리팩토링을 안전하고 쉽게 할 수 있습니다.</li>\n<li>서비스 테스트 (Service Test): 서비스 테스트는 기능의 집합에 집중하여 테스트합니다. 서비스 테스트는 규모, 범위, 테스트 대상에 대한 집중도가 매우 다양합니다. 이 테스트는 프로젝트 전체를 테스트하는 통합 테스트보다는 낮은 단위의 테스트를 하는 것입니다. 작은 기능들의 집합체 수준에서의 테스트를 합니다.</li>\n<li>통합 테스트 (Integration Test): 통합 테스트는 애플리케이션을 통합해서 테스트하는 높은 수준의 테스트입니다. 통합 테스트는 서비스와 낮은 단위의 기능들이 얽혀 모두 제대로 동작하는지에 대한 테스트합니다. 이미 단위 테스트와 서비스 테스트가 따로 있기 때문에 주로 서비스 간의 인터페이스 자체를 이용하여 테스트를 실행합니다.</li>\n</ul>\n<h2 id=\"테스트를-하는-이유\">테스트를 하는 이유</h2>\n<ul>\n<li>제대로 동작하는 소프트웨어를 작성하기 위해서입니다. 현대의 소프트웨어는 직접 제작한 여러 기능들, 다른 사람들이 제작한 여러 라이브러리들로 결합하여 만들기 때문에 하나의 경우에서 제대로 동작한다고 해서 모두 제대로 동작되리라는 보장이 없습니다. 웹의 경우에는 각 브라우저, 버전에서의 차이도 있기 때문에 훨씬더 많은 변수들이 존재합니다. 따라서 테스트를 다양한 방식으로 수행해보면서 소프트웨어에 대한 검증을 다시 해볼 수 있습니다.</li>\n<li>소프트웨어를 테스트하는 과정에서 더 좋은 코드를 작성할 수 있습니다. 테스트 코드를 작성하면서 코드를 작성하다보면 기존에 작성한 코드를 되짚어 보면서 다시 한번 생각할 수 있게 되고, 유연하고 좋은 테스트를 만들기 위해 필연적으로 기능의 통합과 분리를 하게 됩니다. 그리고 가설에 대한 검증을 해보면서 경우의 수를 더 찾아낼 수 있기 때문에 견고한 코드를 생산할 수 있습니다.</li>\n<li>소프트웨어 개발 주기에 테스트를 통합함으로써 코드를 더 자주 릴리즈할 수 있습니다. 앱에 대한 테스트가 있기 때문에 사이드 이펙트에 대한 걱정이 다소 감소할 수 있으며 이는 곧 코드 배포에 대한 자신감으로 이어집니다.</li>\n</ul>\n<h2 id=\"테스트-도구의-분류\">테스트 도구의 분류</h2>\n<ul>\n<li>테스트 실행기 (Test runner): 테스트를 하기 위해서는 테스트를 실행할 도구가 필요합니다. 직접 만든 테스트를 해볼 수도 있겠지만 테스트 도구를 활용한다면 잘 만들어진 테스트 환경에서 쉽게 테스트 할 수 있습니다.</li>\n<li>테스트 더블 (Test doubles): 테스트 코드를 작성할 때 인프라 스트럭처 중에서 문제가 생길 수 있거나 예측할 수 없는 부분은 최대한 테스트에 관여하지 못하게 하고 싶을 때 사용하는 도구입니다. 외부에서 오는 API나 기능들을 가짜 함수로 바꿔주어 실제 테스트 하는 코드에 집중할 수 있게 도와줍니다.</li>\n<li>검증 라이브러리 (Assertion libraries)</li>\n<li>환경 구성 지원 도구 (Environment helpers): 웹의 경우에는 브라우저 환경에서의 동작을 테스트하기 위해서는 DOM, 사용자 이벤트 등이 필요합니다. 테스트 지원 도구들 중에는 이런 환경을 모방하여 해볼 수 있도록 만들어진 것들이 있어 편리하게 기본 브라우저 환경에서의 테스트가 가능합니다.</li>\n<li>프레임워크 전용 라이브러리(Framework specific libraries)</li>\n<li>커버리지 도구 (Coverage tools)</li>\n</ul>\n","data":{"titlePrefix":"Testing","title":"테스트 개요"},"isEmpty":false,"excerpt":"","titlePrefix":"Testing"},{"key":"journal/developments/2020-10-22-VueJS deep.md","title":"deep selector","filename":"2020-10-22-VueJS deep.md","slug":"journal/developments/2020-10-22-VueJS deep","writtenAt":"2020-10-22","categories":["journal","developments"],"postURI":"journal/developments/2020-10-22-VueJS deep.md","content":"<h1 id=\"vuejs-deep\">[VueJS] deep</h1>\n<p>Vue-Loader 에서는 deep selector 라는 강력한 기능을 제공하고 있다.</p>\n<p><a href=\"https://vue-loader.vuejs.org/guide/scoped-css.html#deep-selectors\">https://vue-loader.vuejs.org/guide/scoped-css.html#deep-selectors</a></p>\n<p>상위 컴포넌트에서 하위 컴포넌트의 css에 접근해서 사용할 수 있는 기능으로, 라이브러리를 사용했을 때 라이브러리 컴포넌트 CSS를 따로 사용하기 번거롭거나 해당 라이브러리 컴포넌트 CSS가 Scoped 상태이기를 원할 때 쓸 수 있는 기능이다.</p>\n<p>이 기능은 기본적으로 <code>scoped</code> 상태에서만 활용할 수 있다.</p>\n<p>먼저 간단하게 기본형을 확인해보자.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n    parent\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span>child<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-class\">.parent</span> {\n    <span class=\"hljs-attribute\">color</span>: orangered;\n  }\n\n  <span class=\"hljs-selector-class\">.parent</span> <span class=\"hljs-selector-class\">.child</span> {\n    <span class=\"hljs-attribute\">color</span>: blueviolet;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p><code>Vue</code>는 <code>scoped</code> 상태일 때에는 해당 엘리먼트에 <code>[data-v-난수]</code>(ex: <code>[data-v-2a183b29]</code>)의 형태로 범위를 지정하기 위한 어트리뷰트를 붙이게 된다.</p>\n<p>그리고 CSS를 컴파일 할 때에는 확실한 Scoped의 처리를 위해서 항상 마지막 클래스에 붙인다. 위의 코드가 CSS로 컴파일 되면 다음과 같은 형태가 된다.</p>\n<pre><code class=\"language-html\">/* 편의상 html 이라고 가정한다. */\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-v-2a183b29</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n    parent\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-v-2a183b29</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span>child<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-class\">.parent</span><span class=\"hljs-selector-attr\">[data-v-2a183b29]</span> {\n    <span class=\"hljs-attribute\">color</span>: orangered;\n  }\n\n  <span class=\"hljs-selector-class\">.parent</span> <span class=\"hljs-selector-class\">.child</span><span class=\"hljs-selector-attr\">[data-v-2a183b29]</span> {\n    <span class=\"hljs-attribute\">color</span>: blueviolet;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>이렇게 함으로써 <code>Vue</code>에서는 컴포넌트 단위로 서로 영향을 주지 않는 <code>scoped</code> 처리를 할 수 있게 된다.</p>\n<p>하지만 이렇게 하나의 컴포넌트 단위 안에 있을 때가 아니라 다른 컴포넌트에 있는 클래스에 영향을 주려면 어떻게 해야할까?</p>\n<p>이 이야기에 앞서 상황에 대한 설정이 조금 필요하다. 우선 컴포넌트 단위의 개발론에 입각하여 봤을 때 상위 컴포넌트가 하위 컴포넌트의 CSS에 영향을 주는 일이 &#39;좀처럼&#39; 있어서는 안될 것이다.</p>\n<p>컴포넌트의 개발은 당연히 독립적으로 이루어질 수록 좋으며, 느슨한 연결을 가질 수록 훌륭한 것은 사실이다.</p>\n<p>따라서 이런 상황은 자기 자신의 독립적인 컴포넌트를 제작할 때 발생하는 것이 아니라 다른 라이브러리와 연결하여 사용할 때 발생하는 경우라고 봐야한다.</p>\n<p>특히 그 라이브러리에서 충분한 <code>Style-Props</code>를 충분히 지원하지 않는 경우에 활용할 수 있다.</p>\n<p>라이브러리를 직접 수정하는 것이 아니라 한번 더 감싸서 커스텀한 컴포넌트를 만들고, 자체적으로 CSS를 추가하고자 할 때 이런 <code>deep</code> 기능의 활용이 유용할 것으로 생각된다.</p>\n<p>이런 점을 우선 감안하고 본론으로 넘어가도록 한다.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-class\">.parent</span> {\n    <span class=\"hljs-attribute\">color</span>: orangered;\n  }\n\n  <span class=\"hljs-selector-class\">.parent</span> <span class=\"hljs-selector-class\">.child</span> {\n    <span class=\"hljs-attribute\">color</span>: blueviolet;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p><code>&lt;LibraryComponent /&gt;</code>에 <code>child</code> 클래스(혹은 특정 엘리먼트)가 있다고 가정했을 때 위의 css 로는 child 클래스를 가진 엘리먼트의 폰트 색상을 원하는 색상으로 변경할 수가 없다.</p>\n<p>왜냐하면 <code>[data-v-난수]</code>는 현재 <code>parent</code> 클래스가 있는 컴포넌트에만 붙고, <code>&lt;LibraryComponent /&gt;</code>에는 붙지 않기 때문이다.</p>\n<p>아. 물론 함정이 하나 있다. <code>&lt;LibraryComponent /&gt;</code>의 루트 엘리먼트에는 <code>[data-v-난수]</code>가 동일하게 붙는다. 만약 <code>&lt;LibraryComponent /&gt;</code>의 루트 엘리먼트에 <code>child</code> 클래스가 붙어있다면 위의 코드도 적용이 되겠지만 설명을 위해 <code>child</code> 클래스가 루트 엘리먼트에 있는 것이 아니라고 가정한다. (이런 부분 때문에 처음에 Vue Scoped CSS의 범위를 설정하는 데에는 조금 이해와 인내심이 필요한 것 같다.)</p>\n<p>이 때 <code>&lt;LibarayComponent /&gt;</code>의 <code>child</code> 클래스에 접근하기 위해서 사용할 수 있는 것이 Deep Selector 이다.</p>\n<p>Vue-Loader 에서 기존에는 /deep/ 의 형태로 사용해야 했지만, 이 문법 자체는 deprecated 될 예정이고 &gt;&gt;&gt; 를 쓰는 것을 추천하고 있다.</p>\n<p><a href=\"https://github.com/vuejs/vue-loader/issues/913\">https://github.com/vuejs/vue-loader/issues/913</a></p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-class\">.parent</span> {\n    <span class=\"hljs-attribute\">color</span>: orangered;\n  }\n\n  <span class=\"hljs-selector-class\">.parent</span> &gt;&gt;&gt; <span class=\"hljs-selector-class\">.child</span> {\n    <span class=\"hljs-attribute\">color</span>: blueviolet;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>위와 같이 사용했을 경우 다들 예상했다시피 CSS가 다음과 같이 컴파일 된다.</p>\n<pre><code class=\"language-html\">/* 편의상 html 이라고 가정한다. */\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-v-2a183b29</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n    parent\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> <span class=\"hljs-attr\">data-v-2a183b29</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-v-2a183b29</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span>child<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-class\">.parent</span><span class=\"hljs-selector-attr\">[data-v-2a183b29]</span> {\n    <span class=\"hljs-attribute\">color</span>: orangered;\n  }\n\n  <span class=\"hljs-selector-class\">.parent</span><span class=\"hljs-selector-attr\">[data-v-2a183b29]</span> <span class=\"hljs-selector-class\">.child</span> {\n    <span class=\"hljs-attribute\">color</span>: blueviolet;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>그러면 이제 안전하게(?) <code>&lt;LibraryComponent /&gt;</code> 하위에 있는 <code>child</code> 클래스를 지목하여 폰트 색상을 변경할 수 있다.</p>\n<p>다만, 위의 예시에 보면 엘리먼트를 하나 더 추가했는데 이런 경우에는 자체 컴포넌트에 있는 <code>child</code> 클래스를 가진 엘리먼트의 폰트 색상도 당연히 함께 바뀌게 된다.</p>\n<p>이제까지 본 사실을 토대로 알 수 있겠지만 이 <code>Deep Selector</code>를 사용하는 것은 <code>scoped</code> 라는 기반을 무너뜨릴 수 있는 위험한 존재가 될 수 있다. 당연히 남용하라고 만든 것은 아니며 <em>반드시 필요한 경우에만 사용</em>하는 것이 좋을 것이다.</p>\n<p>하위 컴포넌트에 접근하기 위한 <code>Deep Selector</code>는 되도록이면 최하위 요소 컴포넌트에서 라이브러리 컴포넌트를 사용할 때 정도에 쓰는 것은 안전할 것이다.</p>\n<p><code>SCSS</code> 등과 같은 전처리 도구를 사용할 때에는 아주 조금 확장된 기능을 사용할 순 있다. 미리 이야기해두자면 편리할 순 있지만, 좋은 시선으로 보기 어려운 방법이기 때문에 함께 일하고 있는 경우에는 서로간의 합의와 이해가 필요한 방법이다.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span>\n  .parent {\n    color: orangered;\n  }\n\n  .parent {\n    ::v-deep .child {\n      color: blueviolet;\n    }\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>현재 기준 <code>&quot;sass&quot;: &quot;^1.27.0&quot;, &quot;sass-loader&quot;: &quot;^10.0.4&quot;</code> 에서는 &gt;&gt;&gt; Deep Selector를 지원하지 않으며, <code>::v-deep</code>의 형태로 지원하고 있다.</p>\n<p>여기까지는 이제까지 봤던 Deep Selector와 별반 다르지 않다.</p>\n<p>다음 사례를 보자. 이상한 상황과 수많은 가정을 만들 수 밖에 없는 것을 양해해주기 바란다. 왜냐하면 애초에 이 기능은 극한 상황, 어쩔 수 없는 상황에서나 쓰는 것이지 자주 쓰라는 기능이 아니기 때문이다.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;grand-parent&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;a-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;b-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;c-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;d-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span>\n  .parent {\n    color: orangered;\n  }\n\n  .a-parent {\n    ::v-deep .child {\n      color: chocolate;\n    }\n  }\n  .b-parent {\n    ::v-deep .child {\n      color: darkcyan;\n    }\n  }\n  .c-parent {\n    ::v-deep .child {\n      color: darkslategrey;\n    }\n  }\n  .d-parent {\n    ::v-deep .child {\n      color: blueviolet;\n    }\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>이렇게 부모에 따라서 하위 라이브러리 CSS를 변경해야할 때는 이렇게 늘어뜨려 써야 할 경우가 있다. 전처리 도구를 활용할 경우에는 부모와 자식 클래스를 역전(!)시켜 사용할 수 있다.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;grand-parent&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;a-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;b-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;c-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;d-parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LibraryComponent</span> <span class=\"hljs-attr\">withClass</span>=<span class=\"hljs-string\">&quot;child&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span>\n  .parent {\n    color: orangered;\n  }\n\n  .child {\n    .a-parent &amp; ::v-deep {\n      color: chocolate;\n    }\n    .b-parent &amp; ::v-deep {\n      color: darkcyan;\n    }\n    .c-parent &amp; ::v-deep {\n      color: darkslategrey;\n    }\n    .d-parent &amp; ::v-deep {\n      color: blueviolet;\n    }\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>코드를 좀더 간결하게 볼 수 있다. 서로간에 문법만 제대로 알고 있다면 크게 복잡도가 높지 않을 때에는 사용해 볼 수 있는 방식이다. 다만 일반적으로는 당연히 부모가 자식을 감싸는 것이 맞다고 생각하기 때문에 이 문법을 마냥 좋은 눈으로 보기는 어려워 보인다. 그렇기 때문에 혼자 코드를 작성할 때 어떻게 하든 상관없겠지만, 협업을 할 때에는 협업자들과의 동의 후에 진행하는 것이 좋을 것 같다.</p>\n<p>결론적으로 <code>Deep Selector</code> 언젠가는 필요할 수도 있지만, 남용은 하지말자. 특히 이런 사용할 일이 드물거나 하는 기능은 마이너 버전 업데이트까지는 그래도 괜찮지만, 메이저 버전 업데이트에서는 빠지거나 변경될 가능성이 매우 크다. 안전한 컴포넌트 개발을 통해 미래의 수고를 줄이는 것이 더 좋을테니, 이런 기능이 있다는 정도만 알고 정말 도저히 방법이 없다라는 결론에 도달했을 때만 사용하도록 하자.</p>\n","data":{"titlePrefix":"VueJS","title":"deep selector"},"isEmpty":false,"excerpt":"","titlePrefix":"VueJS"},{"key":"journal/developments/2020-11-17-EncodingForHTTP.md","title":"Encoding for HTTP","filename":"2020-11-17-EncodingForHTTP.md","slug":"journal/developments/2020-11-17-EncodingForHTTP","writtenAt":"2020-11-17","categories":["journal","developments"],"postURI":"journal/developments/2020-11-17-EncodingForHTTP.md","content":"<h1 id=\"자바스크립트의-인코딩과-http-통신\">자바스크립트의 인코딩과 HTTP 통신</h1>\n<p>HTTP 통신을 할 때에 한글이나 특수문자는 인코딩 해주어야 한다.</p>\n<p>특히 특수문자 중에 대표적인 것은 <code>#</code>이 있다.</p>\n<p>URI 규칙에서 <code>#</code>은 HashTag를 의미하기 때문에 인코딩하고 보내지 않을 경우에 문제가 된다.</p>\n<p>아래와 같이 유저들의 정보를 요청하는 API 주소가 있다고 가정을 해보자.</p>\n<pre><code>http://api.server.com/api/#/users</code></pre>\n<p>이 경우, URI 규칙에 의해서 HTTP 전송이 되는 것은 <code>http://api.server.com/api/</code> 까지만이고, <code>#/users</code> 는 HashTag로 인식하게 된다.</p>\n<p>이럴 경우에는 <code>#</code>을 인코딩해야 올바르게 요청을 할 수 있다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">/* psuedo code */</span>\n<span class=\"hljs-keyword\">const</span> hashTag = <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-string\">&quot;#&quot;</span>);\n<span class=\"hljs-keyword\">const</span> requestURL = <span class=\"hljs-string\">`http://api.server.com/api/<span class=\"hljs-subst\">${hashTag}</span>/users`</span>;\nfetch(requestURL)\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.json())\n  .then(<span class=\"hljs-comment\">/* your process */</span>);</code></pre>\n<p>잠깐 이야기를 진행하기에 앞서, 자바스크립트로 브라우저에서 인코딩 작업을 하다보면 <code>encodeURI</code> 와 <code>encodeURIComponent</code> 함수 두 가지를 볼 수 있다. 이 두 개의 차이는 무엇일까?</p>\n<h2 id=\"encodeuri\">encodeURI</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI</a></li>\n<li>MDN에서는 정말 깔끔하게 잘 설명하고 있다.</li>\n</ul>\n</blockquote>\n<p>요점만 보자면 <code>encodeURI</code> 함수는 URI의 규칙에 명시된 예약 문자 모두를 인코딩(escape)하지 않는다.</p>\n<p>대상은 <code>A-Z a-z 0-9 ; , / ? : @ &amp; = + $ - _ . ! ~ * &#39; ( ) #</code> 이 있다. 이 문자들은 URI에서 특별한 의미로 사용하기 때문에 <code>encodeURI</code>로는 인코딩(escape) 하지 않는다.</p>\n<p>따라서 URI 규칙에 잘 따라서 사용한다면 <code>encodeURI</code> 만으로 해결하는 것이 좀더 효율적이고 좋을 수 있다.</p>\n<p>그런데 항상 이렇게 쓸 수는 없다. 자주 예외를 볼 수 있는 사례가 <code>/</code>과 <code>?</code> 그리고 <code>=</code> 정도 일 것이다.</p>\n<p>가령 경우에 따라서 파라미터에 <code>/</code>을 넣어야 할 때가 있다. (<em>특히 파일명과 디렉토리를 불러올 때요!</em>)</p>\n<p>REST API 호출 방식에 따라 GET을 사용하게끔 만들어진 상태에서 다음과 같은 형태로 디렉토리의 폴더를 가져와야 하는 상황이라고 가정해 보겠다. 그리고 파라미터는 인코딩(escape)해서 보내달라는 요청을 받는다.<br><em>당연히 아래 예제와는 전혀 다른 방식으로 호출하게끔 만들어도 되지만, 여기에서는 샘플이 필요하기 때문에 아래와 같이 가정한다.</em></p>\n<pre><code>http://api.server.com/api/files?directory=home/src</code></pre>\n<p>이 경우 <code>home/src</code>에는 <code>/</code>이 있기 때문에 <code>encodeURI</code>로 인코딩할 수 없다.</p>\n<p>그렇다면 이런 경우에는 좀더 확장성이 있는 <code>encodeURIComponent</code>를 활용해야 한다.</p>\n<h2 id=\"encodeuricomponent\">encodeURIComponent</h2>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent</a>\nMDN을 반드시 읽어보는 것이 중요하다.</p>\n</blockquote>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">/* psuedo code */</span>\n<span class=\"hljs-keyword\">const</span> requestURL = <span class=\"hljs-keyword\">new</span> URL(<span class=\"hljs-string\">&quot;http://api.server.com/api/users&quot;</span>);\n<span class=\"hljs-keyword\">const</span> directory = <span class=\"hljs-string\">&quot;home/src&quot;</span>;\n\n<span class=\"hljs-comment\">/* 좀더 효율적으로 사용하려면 requestURL.searchParams.append를 하는 시점에서 encodeURIComponent 를 사용 */</span>\n<span class=\"hljs-keyword\">const</span> encodedDirectory = <span class=\"hljs-built_in\">encodeURIComponent</span>(directory);\n<span class=\"hljs-keyword\">const</span> parameters = { <span class=\"hljs-attr\">directory</span>: encodedDirectory };\n\n<span class=\"hljs-built_in\">Object</span>.keys(parameters).forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span>\n  requestURL.searchParams.append(key, parameters[key])\n);\n\nfetch(requestURL)\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.json())\n  .then(<span class=\"hljs-comment\">/* your process */</span>);</code></pre>\n<p>사실 <code>/</code>는 그냥 보낸다고 하더라도 별 문제는 되지 않는다. URI 규칙에 의해 <code>?</code> 뒤에 있는 <code>/</code>는 그저 파라미터의 일부로 인식되기 때문이다. (<em>물론 숨어있는 위험성은 분명 존재한다. 그 사례는 조금 더 후에 살펴본다.</em>)</p>\n<p>하지만 맨 처음의 사례와 결합하여 보았을 때는 분명 문제가 된다. 디렉토리 이름이 <code>#</code>인 경우에 이스케이프 처리가 되지 않는다면, 어떻게 될까?</p>\n<pre><code>http://api.server.com/api/files?directory=#/src</code></pre>\n<p>첫 사례에서 보았던 것처럼 HTTP 전송은 다음과 같이 될 것이다.</p>\n<pre><code># request URL\nhttp://api.server.com/api/files?directory=\n# HashTag\n/src</code></pre>\n<p>이렇게 나눠져 보내져 버리기 때문에, API 서버는 비어있는 directory 값을 받게 된다. 이것은 <code>#</code>이 어느 위치에 있던지 그 뒤로는 모두 해쉬태그로 인식하게 된다. 따라서 위의 과정을 거쳐서 <code>#</code>도 올바르게 인코딩을 해주어야 한다.</p>\n<p>디렉토리의 사례를 활용해본 김에 좀더 보도록 하자. 위에서 <code>encodeURI</code>는 URI 규칙들을 모두 처리하지 않는다고 하였다. 그렇다면 <code>encodeURIComponent</code>는 어떨까?</p>\n<p>MDN 문서를 토대로 살펴보았을 때 <code>encodeURIComponent</code>는 <code>A-Z a-z 0-9 - _ . ! ~ * &#39; ( )</code>를 제외한 모든 문자를 인코딩한다.</p>\n<h2 id=\"rfc-3986\">RFC 3986</h2>\n<p>그러면 위의 문자열을 제외하고 모두 인코딩처리를 하는 것을 알 수 있다. 하지만 위의 특수기호도 어떻게 될지는 알 수가 없다. 파일의 경우에는 정말 드문 경우일 수도 있겠지만 <code>*</code>이나 <code>!</code> 등을 인코딩할 필요가 있을지도 모른다. 물론 약속에 의해 <code>*</code>를 다른 의미로 활용할 수도 있기 때문에 이 부분은 주의해야 한다. <code>RFC 3986</code> 부터는 <strong>서버와의 규칙</strong>에 준하여 고민하면서 적용해야 한다. <code>RFC 3986</code>은 퍼센트 인코딩 규약을 정의한 것이다. URL에서 중요하게 사용되는 예약(reserved) 문자가 있고, 또한 인코딩이 필요하지 않은 비예약(unreserved) 문자가 있기 때문에 예약 문자를 인코딩 하는 것에 대한 지침이 필요하여 만들어진 것이다.</p>\n<p>그럴 때는 MDN 문서에 나와있는 샘플 코드를 활용하여 인코딩할 수 있다. MDN 문서에는 <code>fixed</code>라고 함수의 이름을 표기했지만 좀더 명확하게 하기 위해 <code>RFC3986</code>으로 대체하여 작성했다.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">encodeURIComponentRFC3986</span>(<span class=\"hljs-params\">str</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">encodeURIComponent</span>(str).replace(<span class=\"hljs-regexp\">/[!&#x27;()*]/g</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">c</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;%&quot;</span> + c.charCodeAt(<span class=\"hljs-number\">0</span>).toString(<span class=\"hljs-number\">16</span>);\n  });\n}\n\n<span class=\"hljs-comment\">/* psuedo code */</span>\n<span class=\"hljs-keyword\">const</span> requestURL = <span class=\"hljs-keyword\">new</span> URL(<span class=\"hljs-string\">&quot;http://api.server.com/api/users&quot;</span>);\n<span class=\"hljs-keyword\">const</span> directory = <span class=\"hljs-string\">&quot;*/src&quot;</span>;\n\n<span class=\"hljs-comment\">/* 좀더 효율적으로 사용하려면 requestURL.searchParams.append를 하는 시점에서 encodeURIComponentRFC3986 을 사용 */</span>\n<span class=\"hljs-keyword\">const</span> encodedDirectory = encodeURIComponentRFC3986(directory);\n<span class=\"hljs-keyword\">const</span> parameters = { <span class=\"hljs-attr\">directory</span>: encodedDirectory };\n\n<span class=\"hljs-built_in\">Object</span>.keys(parameters).forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span>\n  requestURL.searchParams.append(key, parameters[key])\n);\n\nfetch(requestURL)\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.json())\n  .then(<span class=\"hljs-comment\">/* your process */</span>);</code></pre>\n<blockquote>\n<p>거치는 서버가 한대만이 아닐 수도 있다. 특히 URL에 Redirect URL 파라미터를 통해 거쳐가는 경우에는!</p>\n</blockquote>\n<p>특수한 경우를 제외하고는 특수 문자를 그대로 날렸을 때 이상없는 경우가 대부분이긴 하다다. <code>#</code>의 경우에는 처리를 해줄 필요가 분명 있지만, <code>*</code>의 경우에 서버들 사이에서 별 다른 처리를 하지 않아도 해결이 된다면 다행이지만, <code>*</code>이 특별한 의미를 가지게 된 경우라면, 혹은 파라미터를 제외한 도메인에 위치해 있다면, 특히 Redirect URL 파라미터에 포함되어 있다면 상황을 살펴보고 인코딩을 해야할지 잘 판단해야 한다.</p>\n","data":{"titlePrefix":"Knowledge","title":"Encoding for HTTP"},"isEmpty":false,"excerpt":"","titlePrefix":"Knowledge"},{"key":"journal/developments/2020-11-18-DP.md","title":"Dynamic Programming","filename":"2020-11-18-DP.md","slug":"journal/developments/2020-11-18-DP","writtenAt":"2020-11-18","categories":["journal","developments"],"postURI":"journal/developments/2020-11-18-DP.md","content":"","data":{"titlePrefix":"Algorithm","title":"Dynamic Programming"},"isEmpty":false,"excerpt":"","titlePrefix":"Algorithm"},{"key":"journal/developments/2020-11-20-MacFileUpload.md","title":"Mac 응용프로그램 단일 File Upload 문제","filename":"2020-11-20-MacFileUpload.md","slug":"journal/developments/2020-11-20-MacFileUpload","writtenAt":"2020-11-20","categories":["journal","developments"],"postURI":"journal/developments/2020-11-20-MacFileUpload.md","content":"<h1 id=\"mac-응용프로그램-file-upload\">Mac 응용프로그램 File Upload</h1>\n<p>맥북 브라우저에서 단일 파일 업로드를 통해 맥북 응용 프로그램을 업로드하려고 하는 경우에는 다음과 같은 문제가 발생한다.<br>맥북 응용 프로그램은 단일 파일이 아닌 폴더 개념과 비슷하기 때문에 업로드시에 맥북이 자체적으로 zip 으로 압축을 시도한다.<br>따라서 이 와중에 <code>input</code>은 아무 이벤트도 전달받지 못하기 때문에 마치 잠시 컴퓨터가 멈춘 것처럼 된다.</p>\n<pre><code class=\"language-bash\">1. input 에 mac 응용 프로그램 업로드를 시도\n2. macOS 에서 응용 프로그램을 zip 파일로 압축을 시작\n3. 완료될 때까지 input은 아무 이벤트를 받지 못했기 때문에 대기 상태\n4. 이 때에 다른 파일 업로드를 시도하려고 해도 macOS 상에서는 업로드를 위한 프로세스가 진행 중이기 때문에 다른 파일 업로드 불가\n5. zip 파일로 압축이 끝나면 브라우저에 파일을 건네주면서 input change 이벤트가 발생\n6. 파일 업로드가 정상적으로 동작</code></pre>\n<p>압축을 하는 행위가 들어있고, 사실 응용 프로그램 자체는 위에서 언급했듯이 폴더 개념과 다름없기 때문에 단일 파일 업로드를 시도했을 경우에는 이 상황이 필연적으로 발생할 수 밖에 없고 특별히 대응할 수 있는 조치는 없어보인다.</p>\n<p><code>input</code> 에는 파일 업로드에 대한 아무 이벤트도 들어오지 않기 때문에 <code>로딩 UI</code>를 걸어놓을 수도 없다.</p>\n<p>(2020년 기준) 구글 드라이브, 네이버 드라이브 등 몇 가지에서 시도를 해보았지만 모두 별 다른 대응을 하고 있지는 않았다.</p>\n","data":{"titlePrefix":"Knowledge","title":"Mac 응용프로그램 단일 File Upload 문제"},"isEmpty":false,"excerpt":"","titlePrefix":"Knowledge"},{"key":"journal/developments/2020-12-12-CreateBlog.md","title":"블로그 제작기","filename":"2020-12-12-CreateBlog.md","slug":"journal/developments/2020-12-12-CreateBlog","writtenAt":"2020-12-12","categories":["journal","developments"],"postURI":"journal/developments/2020-12-12-CreateBlog.md","content":"<h1 id=\"블로그-제작기\">블로그 제작기</h1>\n<p>블로그를 제작하며 정리하는 글</p>\n","data":{"title":"블로그 제작기"},"isEmpty":false,"excerpt":""}],"children":[]},{"key":"diary","posts":[{"key":"journal/diary/2020-12-17-WaitingForIpad.md","title":"아이패드 오너가 되다","filename":"2020-12-17-WaitingForIpad.md","slug":"journal/diary/2020-12-17-WaitingForIpad","writtenAt":"2020-12-17","categories":["journal","diary"],"postURI":"journal/diary/2020-12-17-WaitingForIpad.md","content":"<h1 id=\"📲-아이패드-프로-오너의-삶\">📲 아이패드 프로 오너의 삶</h1>\n<blockquote>\n<p>아이패드 프로 오너의 삶을 시로 표현해보고자 한다.</p>\n</blockquote>\n<h2 id=\"🐺-아이패드-프로-오너의-삶은-고독하고-고요하다\">🐺 아이패드 프로 오너의 삶은 고독하고, 고요하다.</h2>\n<blockquote>\n<p>그렇기 때문에 더더욱 강해지고 계획적이어야 한다.</p>\n</blockquote>\n<h3 id=\"😀😀😀-그는-아이패드를-기다리고-있다-😀😀😀\">😀😀😀 그는 아이패드를 기다리고 있다. 😀😀😀</h3>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드가 온다. 😀 아이패드가 오면 뭘하지? 그림을 그려야지. 프로 크리에이터를 사야겠다.</li>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드가 온다. 😀 아이패드가 오면 뭘하지? 기획을 해봐야지. 마인드맵을 사야겠다.</li>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드가 온다. 😀 아이패드가 오면 뭘하지? 필기를 해야겠다. 굿노트를 사야겠다.</li>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드가 온다. 😀 아이패드가 오면 뭘하지? 드라마를 봐야겠다. 넷플릭스를 구독해야한다.</li>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드가 온다. 😀 아이패드가 오면 뭘하지? 책을 봐야겠다. 교보 E-book을 구독해야겠다.</li>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드가 온다. 😀 아이패드가 오면 뭘하지? 뭘할까..?</li>\n</ul>\n<h3 id=\"멈출-수-없는-기다림은-그저-코드로-표현할-수-밖에-없다-🤸🏾♀️\">멈출 수 없는 기다림은 그저 코드로 표현할 수 밖에 없다.. 🤸🏾‍♀️</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> getIPAD = <span class=\"hljs-function\">() =&gt;</span>\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      deliveryingIPAD(resolve);\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      someBadThingHappened(reject);\n      never();\n    }\n  });\n\ngetIPAD.then(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-built_in\">Promise</span>.all([\n    drawPicture,\n    planningSomething,\n    writeSomething,\n    watchMovie,\n    readBooks,\n  ]).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> value.isProfit());\n});</code></pre>\n<h2 id=\"아이패드의-중무장을-위한-장비\">아이패드의 중무장을 위한 장비</h2>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 랩씨 아이패드 프로 11인치 종이질감 필름 - 아이패드에게 입혀지기 위해 무려 바다를 건너 달려오고 있다.</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 아이패드 프로 11인치 아이엠듀 케이스 - 말랑말랑한 실리콘 소재로 이루어진 이 케이스는 애플펜슬 2세대 또한 쉽고 간편하게 보관할 수 있다!</li>\n<li><input disabled=\"\" type=\"checkbox\"> 아이패드 스마트 폴리오 매직 키보드 - 엄청나게 높은 구매 가격과 자본력의 한계로 나의 아이패드는 이 아이템을 무장할 수가 없다.</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 애플펜슬 2세대 - 친구에게 선물받은 애플펜슬 2세대. 아이패드 프로 11인치 2세대를 구매하게 된 결정적인 이유이며, 그 날카로운 펜슬의 끝에는 <code>진명황의 집행검</code>이라는 문구가 새겨져있다.</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 애플펜슬 2세대 보호용 실리콘 펜촉팁 8개 - 종이질감의 필름은 애플펜슬의 내구력을 쉽게 약화시키기 때문에 이를 보호하기 위한 8개의 펜촉팁이 대기하고 있다.</li>\n</ul>\n","data":{"title":"아이패드 오너가 되다"},"isEmpty":false,"excerpt":""}],"children":[]},{"key":"free","posts":[{"key":"journal/free/2020-12-14-Brooklyn-Nine-Nine.md","title":"Brooklyn Nine-Nine","filename":"2020-12-14-Brooklyn-Nine-Nine.md","slug":"journal/free/2020-12-14-Brooklyn-Nine-Nine","writtenAt":"2020-12-14","categories":["journal","free"],"postURI":"journal/free/2020-12-14-Brooklyn-Nine-Nine.md","content":"<h1 id=\"브루클린-나인-나인\">브루클린 나인-나인</h1>\n<p>요즘 넷플릭스에서 <code>브루클린 나인-나인</code>이라는 드라마가 눈에 띄어서 보기 시작했는데, 생각보다 재미있어서 계속 보고 있다.<br>경찰들의 이야기인데, <code>오피스</code>라는 드라마를 다 보진 않았지만 몇편 봤을 때의 느낌과 좀 비슷한 것 같기도 하고,</p>\n","data":{"title":"Brooklyn Nine-Nine"},"isEmpty":false,"excerpt":""}],"children":[]}]}},"__N_SSG":true}