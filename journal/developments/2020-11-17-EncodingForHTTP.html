<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/b65855c04a164bc1a9ff.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65855c04a164bc1a9ff.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-2a885b0f9fe0d91a6ecc.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" as="script"/><link rel="preload" href="/_next/static/chunks/cd874f92f6d1699c91a107e773964eb1edecf64e.c4c0821fc1e405eb2232.js" as="script"/><link rel="preload" href="/_next/static/chunks/0330825bb4b60a963845fef84df50f39c18185b3.59202b6886415149c42a.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-65a81d3b4286f2bf201f.js" as="script"/><link rel="preload" href="/_next/static/chunks/24397fd22d9bab5c45aab1ae4d7546ea43385761.6cd9d0f4d7bd2386c84f.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/journal/%5Bclassification%5D/%5BpostName%5D-fcf1a4876d9291565e86.js" as="script"/></head><body><div id="__next"><article class="privateContainerstyled__StyledContainer-sc-1pri6yb-0 kIaQvG"><header class="privateHeaderstyled__StyledHeader-upsiq3-0 cbHKcl"><a href="/" class="privateMainTitlestyled__StyledMainTitleLink-zv7gwu-0 dIbQiW"><h1 class="privateMainTitlestyled__StyledHeadingTitle-zv7gwu-1 ehVxtg"><em>WinterLog</em><span>The Elementary Designer</span></h1></a></header><menu class="privateMainMenustyled__StyledMenu-sc-1nvjugz-0 jtEHgR"><li class="privateMainMenustyled__StyledMenuItem-sc-1nvjugz-1 pQlyx"><a href="/news">News</a></li><li class="privateMainMenustyled__StyledMenuItem-sc-1nvjugz-1 pQlyx on"><a href="/journal">Journal</a></li><li class="privateMainMenustyled__StyledMenuItem-sc-1nvjugz-1 pQlyx"><a href="/profile">Profile</a></li></menu><main class="privateMainstyled__StyledMain-sc-457js4-0 bnYosG"><article class="privatePostArticlestyled__StyledPostArticle-sc-1j9hfm5-0 WNxyx markdown-body"><section><h1 id="자바스크립트의-인코딩과-http-통신">자바스크립트의 인코딩과 HTTP 통신</h1>
<p>HTTP 통신을 할 때에 한글이나 특수문자는 인코딩 해주어야 한다.</p>
<p>특히 특수문자 중에 대표적인 것은 <code>#</code>이 있다.</p>
<p>URI 규칙에서 <code>#</code>은 HashTag를 의미하기 때문에 인코딩하고 보내지 않을 경우에 문제가 된다.</p>
<p>아래와 같이 유저들의 정보를 요청하는 API 주소가 있다고 가정을 해보자.</p>
<pre><code>http://api.server.com/api/#/users</code></pre>
<p>이 경우, URI 규칙에 의해서 HTTP 전송이 되는 것은 <code>http://api.server.com/api/</code> 까지만이고, <code>#/users</code> 는 HashTag로 인식하게 된다.</p>
<p>이럴 경우에는 <code>#</code>을 인코딩해야 올바르게 요청을 할 수 있다.</p>
<pre><code class="language-javascript"><span class="hljs-comment">/* psuedo code */</span>
<span class="hljs-keyword">const</span> hashTag = <span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&quot;#&quot;</span>);
<span class="hljs-keyword">const</span> requestURL = <span class="hljs-string">`http://api.server.com/api/<span class="hljs-subst">${hashTag}</span>/users`</span>;
fetch(requestURL)
  .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json())
  .then(<span class="hljs-comment">/* your process */</span>);</code></pre>
<p>잠깐 이야기를 진행하기에 앞서, 자바스크립트로 브라우저에서 인코딩 작업을 하다보면 <code>encodeURI</code> 와 <code>encodeURIComponent</code> 함수 두 가지를 볼 수 있다. 이 두 개의 차이는 무엇일까?</p>
<h2 id="encodeuri">encodeURI</h2>
<blockquote>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI</a></li>
<li>MDN에서는 정말 깔끔하게 잘 설명하고 있다.</li>
</ul>
</blockquote>
<p>요점만 보자면 <code>encodeURI</code> 함수는 URI의 규칙에 명시된 예약 문자 모두를 인코딩(escape)하지 않는다.</p>
<p>대상은 <code>A-Z a-z 0-9 ; , / ? : @ &amp; = + $ - _ . ! ~ * &#39; ( ) #</code> 이 있다. 이 문자들은 URI에서 특별한 의미로 사용하기 때문에 <code>encodeURI</code>로는 인코딩(escape) 하지 않는다.</p>
<p>따라서 URI 규칙에 잘 따라서 사용한다면 <code>encodeURI</code> 만으로 해결하는 것이 좀더 효율적이고 좋을 수 있다.</p>
<p>그런데 항상 이렇게 쓸 수는 없다. 자주 예외를 볼 수 있는 사례가 <code>/</code>과 <code>?</code> 그리고 <code>=</code> 정도 일 것이다.</p>
<p>가령 경우에 따라서 파라미터에 <code>/</code>을 넣어야 할 때가 있다. (<em>특히 파일명과 디렉토리를 불러올 때요!</em>)</p>
<p>REST API 호출 방식에 따라 GET을 사용하게끔 만들어진 상태에서 다음과 같은 형태로 디렉토리의 폴더를 가져와야 하는 상황이라고 가정해 보겠다. 그리고 파라미터는 인코딩(escape)해서 보내달라는 요청을 받는다.<br><em>당연히 아래 예제와는 전혀 다른 방식으로 호출하게끔 만들어도 되지만, 여기에서는 샘플이 필요하기 때문에 아래와 같이 가정한다.</em></p>
<pre><code>http://api.server.com/api/files?directory=home/src</code></pre>
<p>이 경우 <code>home/src</code>에는 <code>/</code>이 있기 때문에 <code>encodeURI</code>로 인코딩할 수 없다.</p>
<p>그렇다면 이런 경우에는 좀더 확장성이 있는 <code>encodeURIComponent</code>를 활용해야 한다.</p>
<h2 id="encodeuricomponent">encodeURIComponent</h2>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent</a>
MDN을 반드시 읽어보는 것이 중요하다.</p>
</blockquote>
<pre><code class="language-javascript"><span class="hljs-comment">/* psuedo code */</span>
<span class="hljs-keyword">const</span> requestURL = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://api.server.com/api/users&quot;</span>);
<span class="hljs-keyword">const</span> directory = <span class="hljs-string">&quot;home/src&quot;</span>;

<span class="hljs-comment">/* 좀더 효율적으로 사용하려면 requestURL.searchParams.append를 하는 시점에서 encodeURIComponent 를 사용 */</span>
<span class="hljs-keyword">const</span> encodedDirectory = <span class="hljs-built_in">encodeURIComponent</span>(directory);
<span class="hljs-keyword">const</span> parameters = { <span class="hljs-attr">directory</span>: encodedDirectory };

<span class="hljs-built_in">Object</span>.keys(parameters).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span>
  requestURL.searchParams.append(key, parameters[key])
);

fetch(requestURL)
  .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json())
  .then(<span class="hljs-comment">/* your process */</span>);</code></pre>
<p>사실 <code>/</code>는 그냥 보낸다고 하더라도 별 문제는 되지 않는다. URI 규칙에 의해 <code>?</code> 뒤에 있는 <code>/</code>는 그저 파라미터의 일부로 인식되기 때문이다. (<em>물론 숨어있는 위험성은 분명 존재한다. 그 사례는 조금 더 후에 살펴본다.</em>)</p>
<p>하지만 맨 처음의 사례와 결합하여 보았을 때는 분명 문제가 된다. 디렉토리 이름이 <code>#</code>인 경우에 이스케이프 처리가 되지 않는다면, 어떻게 될까?</p>
<pre><code>http://api.server.com/api/files?directory=#/src</code></pre>
<p>첫 사례에서 보았던 것처럼 HTTP 전송은 다음과 같이 될 것이다.</p>
<pre><code># request URL
http://api.server.com/api/files?directory=
# HashTag
/src</code></pre>
<p>이렇게 나눠져 보내져 버리기 때문에, API 서버는 비어있는 directory 값을 받게 된다. 이것은 <code>#</code>이 어느 위치에 있던지 그 뒤로는 모두 해쉬태그로 인식하게 된다. 따라서 위의 과정을 거쳐서 <code>#</code>도 올바르게 인코딩을 해주어야 한다.</p>
<p>디렉토리의 사례를 활용해본 김에 좀더 보도록 하자. 위에서 <code>encodeURI</code>는 URI 규칙들을 모두 처리하지 않는다고 하였다. 그렇다면 <code>encodeURIComponent</code>는 어떨까?</p>
<p>MDN 문서를 토대로 살펴보았을 때 <code>encodeURIComponent</code>는 <code>A-Z a-z 0-9 - _ . ! ~ * &#39; ( )</code>를 제외한 모든 문자를 인코딩한다.</p>
<h2 id="rfc-3986">RFC 3986</h2>
<p>그러면 위의 문자열을 제외하고 모두 인코딩처리를 하는 것을 알 수 있다. 하지만 위의 특수기호도 어떻게 될지는 알 수가 없다. 파일의 경우에는 정말 드문 경우일 수도 있겠지만 <code>*</code>이나 <code>!</code> 등을 인코딩할 필요가 있을지도 모른다. 물론 약속에 의해 <code>*</code>를 다른 의미로 활용할 수도 있기 때문에 이 부분은 주의해야 한다. <code>RFC 3986</code> 부터는 <strong>서버와의 규칙</strong>에 준하여 고민하면서 적용해야 한다. <code>RFC 3986</code>은 퍼센트 인코딩 규약을 정의한 것이다. URL에서 중요하게 사용되는 예약(reserved) 문자가 있고, 또한 인코딩이 필요하지 않은 비예약(unreserved) 문자가 있기 때문에 예약 문자를 인코딩 하는 것에 대한 지침이 필요하여 만들어진 것이다.</p>
<p>그럴 때는 MDN 문서에 나와있는 샘플 코드를 활용하여 인코딩할 수 있다. MDN 문서에는 <code>fixed</code>라고 함수의 이름을 표기했지만 좀더 명확하게 하기 위해 <code>RFC3986</code>으로 대체하여 작성했다.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encodeURIComponentRFC3986</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(str).replace(<span class="hljs-regexp">/[!&#x27;()*]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;%&quot;</span> + c.charCodeAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>);
  });
}

<span class="hljs-comment">/* psuedo code */</span>
<span class="hljs-keyword">const</span> requestURL = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://api.server.com/api/users&quot;</span>);
<span class="hljs-keyword">const</span> directory = <span class="hljs-string">&quot;*/src&quot;</span>;

<span class="hljs-comment">/* 좀더 효율적으로 사용하려면 requestURL.searchParams.append를 하는 시점에서 encodeURIComponentRFC3986 을 사용 */</span>
<span class="hljs-keyword">const</span> encodedDirectory = encodeURIComponentRFC3986(directory);
<span class="hljs-keyword">const</span> parameters = { <span class="hljs-attr">directory</span>: encodedDirectory };

<span class="hljs-built_in">Object</span>.keys(parameters).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span>
  requestURL.searchParams.append(key, parameters[key])
);

fetch(requestURL)
  .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json())
  .then(<span class="hljs-comment">/* your process */</span>);</code></pre>
<blockquote>
<p>거치는 서버가 한대만이 아닐 수도 있다. 특히 URL에 Redirect URL 파라미터를 통해 거쳐가는 경우에는!</p>
</blockquote>
<p>특수한 경우를 제외하고는 특수 문자를 그대로 날렸을 때 이상없는 경우가 대부분이긴 하다다. <code>#</code>의 경우에는 처리를 해줄 필요가 분명 있지만, <code>*</code>의 경우에 서버들 사이에서 별 다른 처리를 하지 않아도 해결이 된다면 다행이지만, <code>*</code>이 특별한 의미를 가지게 된 경우라면, 혹은 파라미터를 제외한 도메인에 위치해 있다면, 특히 Redirect URL 파라미터에 포함되어 있다면 상황을 살펴보고 인코딩을 해야할지 잘 판단해야 한다.</p>
</section></article></main><footer class="privateFooterstyled__StyledFooter-dpt5wm-0 evSZWX"><a href="https://github.com/winterguard" target="_blank" rel="noopener noreferrer" class="privateFooterstyled__StyledFooterLink-dpt5wm-1 eVRegO"><svg height="32" viewBox="0 0 16 16" version="1.1" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></footer></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"content":"\u003ch1 id=\"자바스크립트의-인코딩과-http-통신\"\u003e자바스크립트의 인코딩과 HTTP 통신\u003c/h1\u003e\n\u003cp\u003eHTTP 통신을 할 때에 한글이나 특수문자는 인코딩 해주어야 한다.\u003c/p\u003e\n\u003cp\u003e특히 특수문자 중에 대표적인 것은 \u003ccode\u003e#\u003c/code\u003e이 있다.\u003c/p\u003e\n\u003cp\u003eURI 규칙에서 \u003ccode\u003e#\u003c/code\u003e은 HashTag를 의미하기 때문에 인코딩하고 보내지 않을 경우에 문제가 된다.\u003c/p\u003e\n\u003cp\u003e아래와 같이 유저들의 정보를 요청하는 API 주소가 있다고 가정을 해보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://api.server.com/api/#/users\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우, URI 규칙에 의해서 HTTP 전송이 되는 것은 \u003ccode\u003ehttp://api.server.com/api/\u003c/code\u003e 까지만이고, \u003ccode\u003e#/users\u003c/code\u003e 는 HashTag로 인식하게 된다.\u003c/p\u003e\n\u003cp\u003e이럴 경우에는 \u003ccode\u003e#\u003c/code\u003e을 인코딩해야 올바르게 요청을 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* psuedo code */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hashTag = \u003cspan class=\"hljs-built_in\"\u003eencodeURIComponent\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;#\u0026quot;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e requestURL = \u003cspan class=\"hljs-string\"\u003e`http://api.server.com/api/\u003cspan class=\"hljs-subst\"\u003e${hashTag}\u003c/span\u003e/users`\u003c/span\u003e;\nfetch(requestURL)\n  .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e response.json())\n  .then(\u003cspan class=\"hljs-comment\"\u003e/* your process */\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e잠깐 이야기를 진행하기에 앞서, 자바스크립트로 브라우저에서 인코딩 작업을 하다보면 \u003ccode\u003eencodeURI\u003c/code\u003e 와 \u003ccode\u003eencodeURIComponent\u003c/code\u003e 함수 두 가지를 볼 수 있다. 이 두 개의 차이는 무엇일까?\u003c/p\u003e\n\u003ch2 id=\"encodeuri\"\u003eencodeURI\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMDN에서는 정말 깔끔하게 잘 설명하고 있다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e요점만 보자면 \u003ccode\u003eencodeURI\u003c/code\u003e 함수는 URI의 규칙에 명시된 예약 문자 모두를 인코딩(escape)하지 않는다.\u003c/p\u003e\n\u003cp\u003e대상은 \u003ccode\u003eA-Z a-z 0-9 ; , / ? : @ \u0026amp; = + $ - _ . ! ~ * \u0026#39; ( ) #\u003c/code\u003e 이 있다. 이 문자들은 URI에서 특별한 의미로 사용하기 때문에 \u003ccode\u003eencodeURI\u003c/code\u003e로는 인코딩(escape) 하지 않는다.\u003c/p\u003e\n\u003cp\u003e따라서 URI 규칙에 잘 따라서 사용한다면 \u003ccode\u003eencodeURI\u003c/code\u003e 만으로 해결하는 것이 좀더 효율적이고 좋을 수 있다.\u003c/p\u003e\n\u003cp\u003e그런데 항상 이렇게 쓸 수는 없다. 자주 예외를 볼 수 있는 사례가 \u003ccode\u003e/\u003c/code\u003e과 \u003ccode\u003e?\u003c/code\u003e 그리고 \u003ccode\u003e=\u003c/code\u003e 정도 일 것이다.\u003c/p\u003e\n\u003cp\u003e가령 경우에 따라서 파라미터에 \u003ccode\u003e/\u003c/code\u003e을 넣어야 할 때가 있다. (\u003cem\u003e특히 파일명과 디렉토리를 불러올 때요!\u003c/em\u003e)\u003c/p\u003e\n\u003cp\u003eREST API 호출 방식에 따라 GET을 사용하게끔 만들어진 상태에서 다음과 같은 형태로 디렉토리의 폴더를 가져와야 하는 상황이라고 가정해 보겠다. 그리고 파라미터는 인코딩(escape)해서 보내달라는 요청을 받는다.\u003cbr\u003e\u003cem\u003e당연히 아래 예제와는 전혀 다른 방식으로 호출하게끔 만들어도 되지만, 여기에서는 샘플이 필요하기 때문에 아래와 같이 가정한다.\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://api.server.com/api/files?directory=home/src\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 \u003ccode\u003ehome/src\u003c/code\u003e에는 \u003ccode\u003e/\u003c/code\u003e이 있기 때문에 \u003ccode\u003eencodeURI\u003c/code\u003e로 인코딩할 수 없다.\u003c/p\u003e\n\u003cp\u003e그렇다면 이런 경우에는 좀더 확장성이 있는 \u003ccode\u003eencodeURIComponent\u003c/code\u003e를 활용해야 한다.\u003c/p\u003e\n\u003ch2 id=\"encodeuricomponent\"\u003eencodeURIComponent\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\u003c/a\u003e\nMDN을 반드시 읽어보는 것이 중요하다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* psuedo code */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e requestURL = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e URL(\u003cspan class=\"hljs-string\"\u003e\u0026quot;http://api.server.com/api/users\u0026quot;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e directory = \u003cspan class=\"hljs-string\"\u003e\u0026quot;home/src\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e/* 좀더 효율적으로 사용하려면 requestURL.searchParams.append를 하는 시점에서 encodeURIComponent 를 사용 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e encodedDirectory = \u003cspan class=\"hljs-built_in\"\u003eencodeURIComponent\u003c/span\u003e(directory);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parameters = { \u003cspan class=\"hljs-attr\"\u003edirectory\u003c/span\u003e: encodedDirectory };\n\n\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(parameters).forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n  requestURL.searchParams.append(key, parameters[key])\n);\n\nfetch(requestURL)\n  .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e response.json())\n  .then(\u003cspan class=\"hljs-comment\"\u003e/* your process */\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사실 \u003ccode\u003e/\u003c/code\u003e는 그냥 보낸다고 하더라도 별 문제는 되지 않는다. URI 규칙에 의해 \u003ccode\u003e?\u003c/code\u003e 뒤에 있는 \u003ccode\u003e/\u003c/code\u003e는 그저 파라미터의 일부로 인식되기 때문이다. (\u003cem\u003e물론 숨어있는 위험성은 분명 존재한다. 그 사례는 조금 더 후에 살펴본다.\u003c/em\u003e)\u003c/p\u003e\n\u003cp\u003e하지만 맨 처음의 사례와 결합하여 보았을 때는 분명 문제가 된다. 디렉토리 이름이 \u003ccode\u003e#\u003c/code\u003e인 경우에 이스케이프 처리가 되지 않는다면, 어떻게 될까?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://api.server.com/api/files?directory=#/src\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 사례에서 보았던 것처럼 HTTP 전송은 다음과 같이 될 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# request URL\nhttp://api.server.com/api/files?directory=\n# HashTag\n/src\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 나눠져 보내져 버리기 때문에, API 서버는 비어있는 directory 값을 받게 된다. 이것은 \u003ccode\u003e#\u003c/code\u003e이 어느 위치에 있던지 그 뒤로는 모두 해쉬태그로 인식하게 된다. 따라서 위의 과정을 거쳐서 \u003ccode\u003e#\u003c/code\u003e도 올바르게 인코딩을 해주어야 한다.\u003c/p\u003e\n\u003cp\u003e디렉토리의 사례를 활용해본 김에 좀더 보도록 하자. 위에서 \u003ccode\u003eencodeURI\u003c/code\u003e는 URI 규칙들을 모두 처리하지 않는다고 하였다. 그렇다면 \u003ccode\u003eencodeURIComponent\u003c/code\u003e는 어떨까?\u003c/p\u003e\n\u003cp\u003eMDN 문서를 토대로 살펴보았을 때 \u003ccode\u003eencodeURIComponent\u003c/code\u003e는 \u003ccode\u003eA-Z a-z 0-9 - _ . ! ~ * \u0026#39; ( )\u003c/code\u003e를 제외한 모든 문자를 인코딩한다.\u003c/p\u003e\n\u003ch2 id=\"rfc-3986\"\u003eRFC 3986\u003c/h2\u003e\n\u003cp\u003e그러면 위의 문자열을 제외하고 모두 인코딩처리를 하는 것을 알 수 있다. 하지만 위의 특수기호도 어떻게 될지는 알 수가 없다. 파일의 경우에는 정말 드문 경우일 수도 있겠지만 \u003ccode\u003e*\u003c/code\u003e이나 \u003ccode\u003e!\u003c/code\u003e 등을 인코딩할 필요가 있을지도 모른다. 물론 약속에 의해 \u003ccode\u003e*\u003c/code\u003e를 다른 의미로 활용할 수도 있기 때문에 이 부분은 주의해야 한다. \u003ccode\u003eRFC 3986\u003c/code\u003e 부터는 \u003cstrong\u003e서버와의 규칙\u003c/strong\u003e에 준하여 고민하면서 적용해야 한다. \u003ccode\u003eRFC 3986\u003c/code\u003e은 퍼센트 인코딩 규약을 정의한 것이다. URL에서 중요하게 사용되는 예약(reserved) 문자가 있고, 또한 인코딩이 필요하지 않은 비예약(unreserved) 문자가 있기 때문에 예약 문자를 인코딩 하는 것에 대한 지침이 필요하여 만들어진 것이다.\u003c/p\u003e\n\u003cp\u003e그럴 때는 MDN 문서에 나와있는 샘플 코드를 활용하여 인코딩할 수 있다. MDN 문서에는 \u003ccode\u003efixed\u003c/code\u003e라고 함수의 이름을 표기했지만 좀더 명확하게 하기 위해 \u003ccode\u003eRFC3986\u003c/code\u003e으로 대체하여 작성했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eencodeURIComponentRFC3986\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estr\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eencodeURIComponent\u003c/span\u003e(str).replace(\u003cspan class=\"hljs-regexp\"\u003e/[!\u0026#x27;()*]/g\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;%\u0026quot;\u003c/span\u003e + c.charCodeAt(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e).toString(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e);\n  });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* psuedo code */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e requestURL = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e URL(\u003cspan class=\"hljs-string\"\u003e\u0026quot;http://api.server.com/api/users\u0026quot;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e directory = \u003cspan class=\"hljs-string\"\u003e\u0026quot;*/src\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e/* 좀더 효율적으로 사용하려면 requestURL.searchParams.append를 하는 시점에서 encodeURIComponentRFC3986 을 사용 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e encodedDirectory = encodeURIComponentRFC3986(directory);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parameters = { \u003cspan class=\"hljs-attr\"\u003edirectory\u003c/span\u003e: encodedDirectory };\n\n\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(parameters).forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n  requestURL.searchParams.append(key, parameters[key])\n);\n\nfetch(requestURL)\n  .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e response.json())\n  .then(\u003cspan class=\"hljs-comment\"\u003e/* your process */\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e거치는 서버가 한대만이 아닐 수도 있다. 특히 URL에 Redirect URL 파라미터를 통해 거쳐가는 경우에는!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e특수한 경우를 제외하고는 특수 문자를 그대로 날렸을 때 이상없는 경우가 대부분이긴 하다다. \u003ccode\u003e#\u003c/code\u003e의 경우에는 처리를 해줄 필요가 분명 있지만, \u003ccode\u003e*\u003c/code\u003e의 경우에 서버들 사이에서 별 다른 처리를 하지 않아도 해결이 된다면 다행이지만, \u003ccode\u003e*\u003c/code\u003e이 특별한 의미를 가지게 된 경우라면, 혹은 파라미터를 제외한 도메인에 위치해 있다면, 특히 Redirect URL 파라미터에 포함되어 있다면 상황을 살펴보고 인코딩을 해야할지 잘 판단해야 한다.\u003c/p\u003e\n","data":{"titlePrefix":"Knowledge","title":"Encoding for HTTP"},"isEmpty":false,"excerpt":""}},"__N_SSG":true},"page":"/journal/[classification]/[postName]","query":{"classification":"developments","postName":"2020-11-17-EncodingForHTTP"},"buildId":"TbyTwTwW4kSZl3acOlPhJ","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-f8d88fc6aa27b790f2ac.js"></script><script src="/_next/static/chunks/main-2a885b0f9fe0d91a6ecc.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9116e7bff2bfccdffa19.js" async=""></script><script src="/_next/static/chunks/cd874f92f6d1699c91a107e773964eb1edecf64e.c4c0821fc1e405eb2232.js" async=""></script><script src="/_next/static/chunks/0330825bb4b60a963845fef84df50f39c18185b3.59202b6886415149c42a.js" async=""></script><script src="/_next/static/chunks/pages/_app-65a81d3b4286f2bf201f.js" async=""></script><script src="/_next/static/chunks/24397fd22d9bab5c45aab1ae4d7546ea43385761.6cd9d0f4d7bd2386c84f.js" async=""></script><script src="/_next/static/chunks/pages/journal/%5Bclassification%5D/%5BpostName%5D-fcf1a4876d9291565e86.js" async=""></script><script src="/_next/static/TbyTwTwW4kSZl3acOlPhJ/_buildManifest.js" async=""></script><script src="/_next/static/TbyTwTwW4kSZl3acOlPhJ/_ssgManifest.js" async=""></script></body></html>